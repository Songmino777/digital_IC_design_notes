# 验证基础

### 验证分类

1. 时序验证：时序仿真、STA
2. 功能验证：仿真
   1. 模块级：运行简单案例的仿真
   2. 全芯片级：测试计划中整个芯片所有测试功能都被覆盖
   3. 拓展验证：发现设计中可能“未知”的错误，测试向量未确定。
3. 断言检查：使用设计内部的结构信息，提高可观察性
   - 时间断言：描述信号的时序关系。
   - 静态断言：描述信号的属性，True or False。
4. 形式化验证
5. 等价性检查：利用形式化验证工具，确保RTL与网表之间，逻辑优化与工艺库映射后的网表具有同样的功能。

### 验证的评价

- #### 结构覆盖

  1. 代码覆盖
  2. 翻转覆盖
  3. 分支覆盖

- #### 功能覆盖

### SystemVerilog

#### 数据类型

- 四状态：logic 单比特，integer 32比特有符号，time 64比特无符号

- 双状态：bit，byte，int，shortint，longint，real（双精度浮点）

- 数据结构

  - 定宽数组

    - 与Verilog相比，可以直接指定数组宽度，如 int array \[2][2]，该方式声明的为非合并数组

      e.g.仿真系统为32bit，合并数组将多个8bit数组元素存于同一双字中，但非合并数组分开，只有低8bit，高位不用。

      @操作符可用于标量**或合并数组**，即等待储存器数据变化。逻辑运算符也可用于合并数组。

    - 以常量初始化需要单引号 ‘

  - 动态数组

    - 声明时使用空下标\[]
    - 使用new\[n]分配元素数量为n的空间，使用delete()删除所有元素。

  - 队列

    - 使用下标\[$]初始化
    - 具有delete push_front pop_back等方法，执行很快，但从中间插入 insert 较慢
    - $:n中 \$ 表示第一个元素，反之表示最后一个元素

  - 关联数组

    - 在方括号中放置数据类型（int bit[31:0] string等）
    - 实际为哈希数组，一般用于保存稀疏的元素（如32bit甚至64bit地址的少量数据）
    - 可用字符串索引寻址，可用exists()方法检测有无该元素。

  - 链表

  - 数组方法

    可用于以上除合并数组的所有类型，

    - 遍历：for与foreach（a[i,j]）或foreach（a[i]）

    - 数组缩减：sum，product，and，or
    - 数组定位：min，max，find_index,unique 

  - 结构体

  - 枚举

  - 类型转换

    - 静态转换，直接加单引号，进行隐式转换
    - 动态转换，$(cast) 会对越界等进行检查，但花销更大。

#### task与function

- 两者区别

  - verilog中：

    function包含输入声明并返回一个值，当被调用时，函数立即执行因此在函数中不可以有时间控制结构。相比而言，task结构更加的灵活，该结构可以包含有输入，输出以及双向端口的声明同时可以包含有时间控制结构。可以通过输出和双向端口返回多个值。

    二者主要有以下四个不同点：
    ①、函数只能与主模块共用同一个仿真时间单位，而任务可以定义自己的仿真时间单位；

    ②、函数不能启动任务，任务可以启动其他任务或者函数；

    ③、函数至少要有一个输入变量，而任务可以没有或有多个任何类型的变量；

    ④、函数返回一个值，而任务则不返回值。

  - SV中

    function允许调用task，但仅限于fork......join_none语句

    增加了break，continue，return，允许函数返回void（忽略返回值）

    begin....end变为可选

- 参数

  - SV相比Verilog，允许方向声明与类型声明同时进行。
  - 可带缺省类型 1bit输入**（但一旦使用非缺省类型，后面必须指明，否则默认和前面方向一致）**
  - 支持ref(注意与inout的区别)

- 时间精度与单位

  

